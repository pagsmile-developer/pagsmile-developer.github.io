(window.webpackJsonp=window.webpackJsonp||[]).push([[39],{217:function(e,t,a){"use strict";a.r(t);var r=a(0),s=Object(r.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"verifying-signatures-manually"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#verifying-signatures-manually"}},[e._v("#")]),e._v(" Verifying signatures manually")]),e._v(" "),a("p",[e._v("The approximate content of the Pagsmile-Signature header is as follows (here with line breaks for easy viewing, the actual content is all on one line):")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("Pagsmile-Signature:\nt=1577808000,\nv2=5257a869e7ecebeda32affa62cdca3fa51cad7e77a0e56ff536d0ce8e108d8bd\n")])])]),a("p",[e._v("The Pagsmile-Signature header contains a timestamp and a signature. The timestamp is prefixed by t=, followed by a UNIX timestamp; the signature is prefixed by v2=, followed by the signature content.")]),e._v(" "),a("p",[e._v("The notification sent uses the following format:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('Content-Type: application/json\nMethod: POST\nHeader: Pagsmile-Signature\nBody:\n  {\n    "trade_no":"",\n  \t"out_trade_no":"",\n  \t"out_request_no":"",\n  \t"app_id":"",\n  \t"trade_status":"",\n  \t"amount":"",\n  \t"method":"",\n  \t"currency":"",\n    "timestamp":""\n  }\n')])])]),a("h3",{attrs:{id:"step-1-extract-the-timestamp-and-signatures-from-the-header"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#step-1-extract-the-timestamp-and-signatures-from-the-header"}},[e._v("#")]),e._v(" Step 1 : Extract the timestamp and signatures from the header")]),e._v(" "),a("p",[e._v("Split the header using the [,] character as the separator, to get a list of elements. Then split each element using the [=] character as the separator, to get a prefix and value pair.")]),e._v(" "),a("p",[e._v("The value for the prefix [t] corresponds to the timestamp, and [v2] corresponds to the signature. You can discard all other elements.")]),e._v(" "),a("h3",{attrs:{id:"step-2-prepare-the-original-requestbody-string"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#step-2-prepare-the-original-requestbody-string"}},[e._v("#")]),e._v(" Step 2 : Prepare the original RequestBody string")]),e._v(" "),a("p",[e._v("Get all the content in the RequestBody. Please pay attention here. Please do not use the program's self-built structure to format and/or serialize the RequestBody content. If you have similar requirements, please do it after getting the original data for verification to avoid unnecessary sorting of fields and the addition of characters affect the signature.")]),e._v(" "),a("h3",{attrs:{id:"step-3-determine-the-expected-signature"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#step-3-determine-the-expected-signature"}},[e._v("#")]),e._v(" Step 3 : Determine the expected signature")]),e._v(" "),a("p",[e._v("Compute an HMAC with the SHA256 hash function. Use the SecretKey get from The merchant dashboard as the key(salt), and use the original RequestBody string as the message.")]),e._v(" "),a("h3",{attrs:{id:"step-4-compare-the-signatures"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#step-4-compare-the-signatures"}},[e._v("#")]),e._v(" Step 4 : Compare the signatures")]),e._v(" "),a("p",[e._v("Compare the signature in the header to the expected signature. For an equality match, compute the difference between the current timestamp and the received timestamp, then decide if the difference is within your tolerance.")])])}),[],!1,null,null,null);t.default=s.exports}}]);